import math
import random

import netsquid as ns
import networkx as nx
import numpy as np
from netsquid.nodes import Node
from netsquid.protocols.protocol import Protocol

from event_generators import AnnouncementGenerator, RequestGenerator
from import_data import import_data
from network_benchmarking.entanglement_nb_protocol import (NBProtocolAlice,
                                                           NBProtocolBob)
from packets import RoutingRequest
from protocols import BGPProtocol, create_qprocessor
from utils import REGRESSION, EntanglingConnectionOnDemand, RoutingPath


class QuantumNetwork(Protocol):
    '''Control the simulation of the whole network.'''

    def __init__(self, channel_noise_rate=0, gate_noise_rate=0, max_path_num=10, avg_link_length=10):
        """Initialize the parameters of the network.

        Parameters
        ----------
        channel_noise_rate : float
            The probability that qubits generated by `EntanglingConnectionOnDemand` will depolarize.

        gate_noise_rate : float
            The probability that quantum operation results will depolarize.

        max_path_num : int
            The maximum number of paths stored in the routing table for each destination.

        avg_link_length : int
            The average length (in km) of the quantum links between different ASes.
        """

        self.channel_noise_rate = channel_noise_rate
        self.gate_noise_rate = gate_noise_rate
        self.max_path_num = max_path_num
        self.avg_link_length = avg_link_length
        self.routing_table_benchmarked = {}

        self.initialize_network_simple_example()
        # self.initialize_network_real_topology(max_node_num=1000)

    def initialize_network_simple_example(self):
        """Initialize an artificial simple network for debugging purposes."""
        super().__init__()
        # Initialize nodes in the network, and let them know who their neighbors are
        # Currently use a simple example of 7 nodes
        self.as_dict = {n: AS(self, n) for n in range(1, 8)}
        self.ip_list = ["1.1.1.1", "2.2.2.2", "3.3.3.3", "4.4.4.4"]
        self.protocols = {}

        # Initialize BGP speakers for each AS
        speaker_id = 1
        speaker_number_in_as = [1, 2, 2, 1, 3, 2, 2]
        self.speaker_dict = {}
        for asn, as_node in self.as_dict.items():
            for _ in range(speaker_number_in_as[asn - 1]):
                as_node.add_speaker(speaker_id, 10)
                speaker_id += 1
            self.speaker_dict |= as_node.speakers

        # Initialize connection between speakers
        edges = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 8), (7, 8), (7, 9), (8, 9), (9, 10), (10, 11), (11, 12),
                 (12, 13), (13, 1), (3, 7), (5, 7)]
        for (a, b) in edges:
            self.connect(a, b)

        # Initialize BGP announcement generators
        announcement_protocol1 = AnnouncementGenerator(self.as_dict[5], ["1.1.1.1", "2.2.2.2"], "Poisson", 10, 100)
        announcement_protocol2 = AnnouncementGenerator(self.as_dict[1], ["3.3.3.3", "4.4.4.4"], "Poisson", 10, 100)

        # Initialize protocols for the speakers
        for speaker in self.speaker_dict.values():
            protocol = BGPProtocol(speaker)
            self.protocols[speaker.speaker_id] = protocol
            protocol.start()

        announcement_protocol1.start()
        announcement_protocol2.start()

    def initialize_speakers(self, G, capacity=10, max_neighbors_num=5):
        """Initial the speakers given an AS network topology.

        The topology only contains ASes and their connections. So we use parameter `max_neighbors_num`
        to determine the number of speakers in each AS.

        Specifically, each AS has `ceil(AS.degree / max_neighbors_num)` speakers.

        Parameters
        ----------
        G : Networkx Graph object
            The network topology, where each node represents an AS.
        capacity : int, optional
            The maximum number of qubits that a speaker can store. Default is 10.
        max_neighbors_num : int, optional
            The maximum number of neighbors that a speaker can connect with. Default is 5.
        """
        # Initialize AS, speakers, etc.
        self.as_dict = {n: AS(self, n) for n in G}

        speaker_id = 1
        self.speaker_dict = {}
        for a, b in G.edges:
            as_a = self.as_dict[a]
            as_b = self.as_dict[b]

            as_a_neighbors_num = as_a.neighbor_speaker_num()
            as_b_neighbors_num = as_b.neighbor_speaker_num()

            if as_a_neighbors_num // max_neighbors_num >= len(as_a.speakers):
                as_a.add_speaker(speaker_id, capacity=capacity)
                speaker_id += 1
            if as_b_neighbors_num // max_neighbors_num >= len(as_b.speakers):
                as_b.add_speaker(speaker_id, capacity=capacity)
                speaker_id += 1
            speaker_id1 = max(as_a.speakers.keys())
            speaker_id2 = max(as_b.speakers.keys())
            self.speaker_dict |= as_a.speakers | as_b.speakers
            self.connect(speaker_id1, speaker_id2)  # Connect external connections

        # For each AS, connect its speakers using internal connections
        for n in G.nodes:
            as_node = self.as_dict[n]
            speaker_id_list = list(as_node.speakers.keys())

            # Only connect speakers internally if the AS has more than 1 speaker
            if len(speaker_id_list) > 1:
                # # Iterate over pairs in a list (circular fashion)
                # for speaker1_id, speaker2_id in pairs(speaker_id_list):
                #     self.connect(speaker1_id, speaker2_id)
                # TODO: we cannot use circular fashion, so simply connect all the pairs
                for speaker1_id in speaker_id_list:
                    for speaker2_id in speaker_id_list:
                        if speaker1_id != speaker2_id:
                            self.connect(speaker1_id, speaker2_id)

    def initialize_random_waxman_topology(self, node_num, ip_num, capacity, max_neighbors_num):
        """Initialize a random Waxman network topology."""

        G = nx.waxman_graph(node_num)
        # Get the largest connected component to make sure it is connected
        largest_component = max(nx.connected_components(G), key=len)
        G = G.subgraph(largest_component).copy()
        assert nx.is_connected(G)
        self.initialize_speakers(G, capacity=capacity, max_neighbors_num=max_neighbors_num)

        self.ip_list = [f"{i}.{i}.{i}.{i}" for i in range(1, ip_num + 1)]

        # Initialize BGP announcement generators
        for ip in self.ip_list:
            random_as = random.choice(list(self.as_dict.values()))
            protocol = AnnouncementGenerator(random_as, [ip], "Poisson", 10, 100)
            protocol.start()

        # Initialize protocols for the speakers
        self.protocols = {}
        for speaker in self.speaker_dict.values():
            protocol = BGPProtocol(speaker)
            self.protocols[speaker.speaker_id] = protocol
            protocol.start()

    def initialize_random_AS_topology(self, node_num, ip_num, capacity, max_neighbors_num):
        """Initialize a random topology resembling the Internet AS network."""

        G = nx.random_internet_as_graph(node_num)
        # import matplotlib.pyplot as plt
        # nx.draw(G, with_labels=True)
        # plt.show()
        assert nx.is_connected(G)
        self.initialize_speakers(G, capacity=capacity, max_neighbors_num=max_neighbors_num)

        self.ip_list = [f"{i}.{i}.{i}.{i}" for i in range(1, ip_num + 1)]

        # Initialize BGP announcement generators
        for ip in self.ip_list:
            random_as = random.choice(list(self.as_dict.values()))
            protocol = AnnouncementGenerator(random_as, [ip], "Poisson", 10, 100)
            protocol.start()

        # Initialize protocols for the speakers
        self.protocols = {}
        for speaker in self.speaker_dict.values():
            protocol = BGPProtocol(speaker)
            self.protocols[speaker.speaker_id] = protocol
            protocol.start()

    def initialize_network_real_topology(self, node_num, ip_num, capacity, max_neighbors_num):
        """Initialize a network that uses real-world topology."""

        G = import_data(node_num=node_num)  # Import real-world network topology
        assert nx.is_connected(G)
        self.initialize_speakers(G, capacity=capacity, max_neighbors_num=max_neighbors_num)

        self.ip_list = [f"{i}.{i}.{i}.{i}" for i in range(1, ip_num + 1)]

        # Initialize BGP announcement generators
        for ip in self.ip_list:
            random_as = random.choice(list(self.as_dict.values()))
            protocol = AnnouncementGenerator(random_as, [ip], "Poisson", 10, 100)
            protocol.start()

        # Initialize protocols for the speakers
        self.protocols = {}
        for speaker in self.speaker_dict.values():
            protocol = BGPProtocol(speaker)
            self.protocols[speaker.speaker_id] = protocol
            protocol.start()

    def benchmark(self, source_speaker_id, dest_speaker_id, IP):
        """Run network benchmarking between two speakers. This is not the final interface we want, so it's for debugging only."""
        source_speaker = self.speaker_dict[source_speaker_id]
        dest_speaker = self.speaker_dict[dest_speaker_id]

        bounces = list(range(6, 11))
        sample_times = {}
        for i in bounces:
            sample_times[i] = 5

        alice_protocol = NBProtocolAlice(source_speaker,
                                         self.protocols[source_speaker_id],
                                         bounce=bounces,
                                         num_samples=sample_times,
                                         target_ip=IP)
        bob_protocol = NBProtocolBob(dest_speaker)

        alice_protocol.set_target_protocol(bob_protocol)
        bob_protocol.set_target_protocol(alice_protocol)

        alice_protocol.start()
        bob_protocol.start()
        ns.sim_run()

        print(alice_protocol.data_processing())

    def benchmark_path(self, source_as, path, bounces, sample_times):
        """Run network benchmarking from AS `source_as` along `path`."""
        # Find the source speaker in `source_as`
        assert len(path.as_list) > 0
        first_as = path.as_list[0]
        source_speaker = self.get_speaker_to_as(source_as, first_as)

        if source_speaker is None:
            print(f"Error: cannot find the first speaker inside {source_as} to go through path {path}.")
            print(f"Seems like {source_as} and {first_as} are not connected.")
            exit(1)

        destination_speaker = self.get_destination_speaker_via_path(source_speaker, path)

        print(f"Path: {path}, source speaker: {source_speaker}, destination speaker: {destination_speaker}")

        alice_protocol = NBProtocolAlice(source_speaker, bounce=bounces, num_samples=sample_times, path=path)
        bob_protocol = NBProtocolBob(destination_speaker)

        alice_protocol.set_target_protocol(bob_protocol)
        bob_protocol.set_target_protocol(alice_protocol)

        alice_protocol.start()
        bob_protocol.start()
        # ns.sim_run()

        # return alice_protocol.return_data()
        return alice_protocol

    def naive_network_benchmarking(self, source_as, path_list, bounces, sample_times, return_raw_data=False):
        path_number = len(path_list)
        mean_bm = {}
        fidelity = []
        protocol = []
        for path_num in range(path_number):
            protocol.append(self.benchmark_path(source_as, path_list[path_num], bounces, sample_times))
        ns.sim_run()
        for path_num in range(path_number):
            mean_values = protocol[path_num].return_data()
            mean_bm[path_num] = mean_values
            print(mean_values)
            print(fidelity)
            fidelity.append(REGRESSION(bounces, mean_values)[0])
        del protocol
        if return_raw_data:
            return mean_bm
        else:
            return fidelity

    def online_top_k_path_selection(self,
                                    source_as,
                                    path_list,
                                    K,
                                    init_bounces,
                                    init_sample_times,
                                    loop_bounces,
                                    budget=100,
                                    delta=0.05,
                                    h1=0.85,
                                    h2=0.8):
        path_number = len(path_list)
        initial_estimated_p = []
        initial_estimated_A = []
        protocol = []
        for path_num in range(path_number):
            protocol.append(self.benchmark_path(source_as, path_list[path_num], init_bounces, init_sample_times))
        ns.sim_run()
        for path_num in range(path_number):
            mean_values = protocol[path_num].return_data()
            initial_estimated_p.append(REGRESSION(init_bounces, mean_values)[0])
            initial_estimated_A.append(REGRESSION(init_bounces, mean_values)[1])
        print(initial_estimated_p)
        print(initial_estimated_A)
        del protocol
        estimated_A = np.mean(initial_estimated_A)

        m_max = max(loop_bounces)
        m_min = min(loop_bounces)
        # record
        total_bounces = sum(init_bounces) * init_sample_times[init_bounces[0]] * path_number

        bounces_for_each_path = np.zeros((path_number), dtype=int)

        num_selected = np.zeros((path_number), dtype=int)  # track # of times selected for each arm
        cumulative_p = np.zeros((path_number), dtype=float)  # track cumulative reward for each arm
        estimated_p = np.zeros((path_number), dtype=float)  # track estimate reward for each arm
        ucb_p = np.ones((path_number), dtype=float)
        lcb_p = np.zeros((path_number), dtype=float)

        # cumulative_num = np.zeros((path_number, (m_max -m_min)), dtype=int)
        # cumulative_bmi = np.zeros((path_number, (m_max - m_min)), dtype=float)
        # estimated_bmi = np.zeros((path_number, (m_max - m_min)), dtype=float)

        good_arm_set = []
        bad_arm_set = []

        arm_set = list(range(path_number))
        arm_ucb_dict = {}
        arm_lcb_dict = {}
        for i in arm_set:
            arm_ucb_dict[i] = 1
            arm_lcb_dict[i] = 0

        for path in arm_set:
            estimated_p[path] = initial_estimated_p[path]
            num_selected[path] = 1

        for round in range(1, budget + 1):
            protocols = []
            bounces_temp = []
            for arm in arm_set:
                bounce_for_arm = np.argmax(
                    [32 * estimated_A**2 * m**1 * (estimated_p[arm])**(4 * m - 2) for m in loop_bounces]) + m_min
                bounce_for_arm = int(bounce_for_arm)
                bounce_for_arm = bounce_for_arm if bounce_for_arm > 5 else 5
                bounce_for_arm = random.choice(list(range(m_min, bounce_for_arm + 1)))
                bounces_for_each_path[arm] += bounce_for_arm
                total_bounces += bounce_for_arm
                print("bounce_for_arm", bounce_for_arm)
                protocols.append(self.benchmark_path(source_as, path_list[arm], bounce_for_arm, {bounce_for_arm: 1}))
                bounces_temp.append(bounce_for_arm)
            ns.sim_run()
            for i in range(len(arm_set)):
                arm = arm_set[i]
                current_bmi = protocols[i].return_data()[0]
                if math.isnan(current_bmi):
                    current_bmi = 0
                if current_bmi < 0:
                    current_bmi = abs(current_bmi)
                # print(current_bmi)
                p = pow(current_bmi / estimated_A, 1.0 / float(2 * bounces_temp[i]))
                print(p)
                num_selected[arm] += 1
                cumulative_p[arm] += float(p)
                estimated_p[arm] = cumulative_p[arm] / float(num_selected[arm] - 1)

                ucb_p[arm] = (estimated_p[arm] + np.sqrt(np.log(2 * round**2 * path_number / delta) / float(2 * round)))
                arm_ucb_dict[arm] = ucb_p[arm]
                lcb_p[arm] = (estimated_p[arm] - np.sqrt(np.log(2 * round**2 * path_number / delta) / float(2 * round)))
                arm_lcb_dict[arm] = lcb_p[arm]
            del protocols
            print("arm_lcb_dict", arm_lcb_dict)
            print("arm_ucb_dict", arm_ucb_dict)

            sort_list = sorted(arm_ucb_dict.items(), key=lambda x: x[1], reverse=True)
            top_k_arms = [x[0] for x in sort_list][0:K - len(good_arm_set)]
            left_arms = [x[0] for x in sort_list][K - len(good_arm_set):]

            temp_lcb_values = [arm_lcb_dict[key] for key in top_k_arms]
            min_lcb = min(temp_lcb_values)
            temp_ucb_values = [arm_ucb_dict[key] for key in left_arms]
            max_ucb = max(temp_ucb_values)
            # print(min_lcb, max_ucb)
            temp_set = []
            for arm1 in left_arms:
                if min_lcb > arm_ucb_dict[arm1]:
                    temp_set.append(arm1)
                    bad_arm_set.append(arm1)

            for arm2 in top_k_arms:
                if max_ucb < arm_lcb_dict[arm2]:
                    temp_set.append(arm2)
                    good_arm_set.append(arm2)

            temp_set = list(set(temp_set))
            for i in temp_set:
                arm_set.remove(i)
                arm_ucb_dict.pop(i)
                arm_lcb_dict.pop(i)
                if i in top_k_arms:
                    top_k_arms.remove(i)
                if i in left_arms:
                    left_arms.remove(i)

            if len(bad_arm_set) >= path_number - K or len(good_arm_set) >= K:
                print("current round:", round)
                print("selected:", good_arm_set)
                print("total_bounces", total_bounces)
                print("selection times for each arm:", num_selected)
                print("estimation results for each arm:", estimated_p)
                break

            temp_lcb_values = [arm_lcb_dict[key] for key in top_k_arms]
            min_lcb = min(temp_lcb_values)
            temp_ucb_values = [arm_ucb_dict[key] for key in left_arms]
            max_ucb = max(temp_ucb_values)

            if min_lcb > h1:
                print("good case")
                print("current round:", round)
                print("selected:", good_arm_set + top_k_arms)
                print("total_bounces", total_bounces)
                print("selection times for each arm:", num_selected)
                print("estimation results for each arm:", estimated_p)
                break

            if max_ucb < h2:
                print("bad case")
                print("current round:", round)
                print("selected:", good_arm_set + top_k_arms)
                print("total_bounces", total_bounces)
                print("selection times for each arm:", num_selected)
                print("estimation results for each arm:", estimated_p)
                break

        if round == budget:
            print("current round:", round)
            print("selected:", good_arm_set)
            print("total_bounces", total_bounces)
            print("selection times for each arm:", num_selected)
            print("estimation results for each arm:", estimated_p)

        data_list = {}
        data_list["good_arm_set"] = good_arm_set + top_k_arms
        data_list["num_selected"] = num_selected
        data_list["fidelity"] = estimated_p
        data_list["total_bounces"] = total_bounces
        data_list["bounces_for_each_path"] = bounces_for_each_path
        data_list["round_stopped"] = round

        return data_list

    def online_top_k_path_selection_without_information_gain(self,
                                                             source_as,
                                                             path_list,
                                                             K,
                                                             init_bounces,
                                                             init_sample_times,
                                                             loop_bounces,
                                                             budget=100,
                                                             delta=0.05,
                                                             h1=0.85,
                                                             h2=0.8):
        path_number = len(path_list)
        initial_estimated_p = []
        initial_estimated_A = []
        protocol = []
        for path_num in range(path_number):
            protocol.append(self.benchmark_path(source_as, path_list[path_num], init_bounces, init_sample_times))
        ns.sim_run()
        for path_num in range(path_number):
            mean_values = protocol[path_num].return_data()
            initial_estimated_p.append(REGRESSION(init_bounces, mean_values)[0])
            initial_estimated_A.append(REGRESSION(init_bounces, mean_values)[1])
        print(initial_estimated_p)
        print(initial_estimated_A)
        del protocol
        estimated_A = np.mean(initial_estimated_A)

        m_max = max(loop_bounces)
        m_min = min(loop_bounces)
        # record
        total_bounces = sum(init_bounces) * init_sample_times[init_bounces[0]] * path_number

        bounces_for_each_path = np.zeros((path_number), dtype=int)

        num_selected = np.zeros((path_number), dtype=int)  # track # of times selected for each arm
        cumulative_p = np.zeros((path_number), dtype=float)  # track cumulative reward for each arm
        estimated_p = np.zeros((path_number), dtype=float)  # track estimate reward for each arm
        ucb_p = np.ones((path_number), dtype=float)
        lcb_p = np.zeros((path_number), dtype=float)

        # cumulative_num = np.zeros((path_number, (m_max -m_min)), dtype=int)
        # cumulative_bmi = np.zeros((path_number, (m_max - m_min)), dtype=float)
        # estimated_bmi = np.zeros((path_number, (m_max - m_min)), dtype=float)

        good_arm_set = []
        bad_arm_set = []

        arm_set = list(range(path_number))
        arm_ucb_dict = {}
        arm_lcb_dict = {}
        for i in arm_set:
            arm_ucb_dict[i] = 1
            arm_lcb_dict[i] = 0

        for path in arm_set:
            estimated_p[path] = initial_estimated_p[path]
            num_selected[path] = 1

        for round in range(1, budget + 1):
            protocols = []
            bounces_temp = []
            for arm in arm_set:
                # bounce_for_arm = np.argmax(
                #     [32 * estimated_A**2 * m**1 * (estimated_p[arm])**(4 * m - 2) for m in loop_bounces]) + m_min
                # bounce_for_arm = int(bounce_for_arm)
                bounce_for_arm = random.choice(loop_bounces)
                bounces_for_each_path[arm] += bounce_for_arm
                total_bounces += bounce_for_arm
                print("bounce_for_arm", bounce_for_arm)
                protocols.append(self.benchmark_path(source_as, path_list[arm], bounce_for_arm, {bounce_for_arm: 1}))
                bounces_temp.append(bounce_for_arm)
            ns.sim_run()
            for i in range(len(arm_set)):
                arm = arm_set[i]
                current_bmi = protocols[i].return_data()[0]
                if math.isnan(current_bmi):
                    current_bmi = 0
                if current_bmi < 0:
                    current_bmi = abs(current_bmi)
                p = pow(current_bmi / estimated_A, 1.0 / float(2 * bounces_temp[i]))
                print(p)
                if math.isnan(p):
                    pass
                num_selected[arm] += 1
                cumulative_p[arm] += float(p)
                estimated_p[arm] = cumulative_p[arm] / float(num_selected[arm] - 1)
                if math.isnan(estimated_p[arm]):
                    pass
                ucb_p[arm] = (estimated_p[arm] + np.sqrt(np.log(2 * round**2 * path_number / delta) / float(2 * round)))
                arm_ucb_dict[arm] = ucb_p[arm]
                lcb_p[arm] = (estimated_p[arm] - np.sqrt(np.log(2 * round**2 * path_number / delta) / float(2 * round)))
                arm_lcb_dict[arm] = lcb_p[arm]
            del protocols
            print("arm_lcb_dict", arm_lcb_dict)
            print("arm_ucb_dict", arm_ucb_dict)

            sort_list = sorted(arm_ucb_dict.items(), key=lambda x: x[1], reverse=True)
            top_k_arms = [x[0] for x in sort_list][0:K - len(good_arm_set)]
            left_arms = [x[0] for x in sort_list][K - len(good_arm_set):]

            temp_lcb_values = [arm_lcb_dict[key] for key in top_k_arms]
            min_lcb = min(temp_lcb_values)
            temp_ucb_values = [arm_ucb_dict[key] for key in left_arms]
            max_ucb = max(temp_ucb_values)
            # print(min_lcb, max_ucb)
            temp_set = []
            for arm1 in left_arms:
                if min_lcb > arm_ucb_dict[arm1]:
                    temp_set.append(arm1)
                    bad_arm_set.append(arm1)

            for arm2 in top_k_arms:
                if max_ucb < arm_lcb_dict[arm2]:
                    temp_set.append(arm2)
                    good_arm_set.append(arm2)

            temp_set = list(set(temp_set))
            for i in temp_set:
                arm_set.remove(i)
                arm_ucb_dict.pop(i)
                arm_lcb_dict.pop(i)
                if i in top_k_arms:
                    top_k_arms.remove(i)
                if i in left_arms:
                    left_arms.remove(i)

            if len(bad_arm_set) >= path_number - K or len(good_arm_set) >= K:
                print("current round:", round)
                print("selected:", good_arm_set)
                print("total_bounces", total_bounces)
                print("selection times for each arm:", num_selected)
                print("estimation results for each arm:", estimated_p)
                break

            temp_lcb_values = [arm_lcb_dict[key] for key in top_k_arms]
            min_lcb = min(temp_lcb_values)
            temp_ucb_values = [arm_ucb_dict[key] for key in left_arms]
            max_ucb = max(temp_ucb_values)

            if min_lcb > h1:
                print("good case")
                print("current round:", round)
                print("selected:", good_arm_set + top_k_arms)
                print("total_bounces", total_bounces)
                print("selection times for each arm:", num_selected)
                print("estimation results for each arm:", estimated_p)
                break

            if max_ucb < h2:
                print("bad case")
                print("current round:", round)
                print("selected:", good_arm_set + top_k_arms)
                print("total_bounces", total_bounces)
                print("selection times for each arm:", num_selected)
                print("estimation results for each arm:", estimated_p)
                break

        if round == budget:
            print("current round:", round)
            print("selected:", good_arm_set)
            print("total_bounces", total_bounces)
            print("selection times for each arm:", num_selected)
            print("estimation results for each arm:", estimated_p)

        data_list = {}
        data_list["good_arm_set"] = good_arm_set + top_k_arms
        data_list["num_selected"] = num_selected
        data_list["fidelity"] = estimated_p
        data_list["total_bounces"] = total_bounces
        data_list["bounces_for_each_path"] = bounces_for_each_path
        data_list["round_stopped"] = round

        return data_list

    def get_destination_speaker_via_path(self, source_speaker, path):
        """Given a `source_speaker`, pretend to route a request via `path` until a destination speaker and return it."""
        next_speaker = source_speaker
        index = 0
        while index < len(path.as_list):
            next_as = path.as_list[index]
            next_speaker = next_speaker.find_next_speaker_via_asn(next_as.asn)
            if next_speaker.asn == next_as.asn:  # If we successfully go to the next AS
                index += 1

        return next_speaker

    def get_speaker_to_as(self, source_as, next_as):
        """Get a speaker inside `source_as` that directly connects to `next_as`."""
        for speaker in source_as.speakers.values():
            for other_speaker in speaker.e_neighbors:
                if other_speaker.asn == next_as.asn:
                    return speaker
        # Return None if not found
        return None

    def get_paths(self, source_as, ip, max_num=None):
        """Requests to access IP address `ip` from AS `source_as` and returns a set of paths.
        The number of paths is at most `max_num`.

        Parameters
        ----------
        source_as : AS
            Source Autonomous System.
        IP : str
            Destination IP address.
        max_num : int, optional
            The maximum number of returned paths.
            If it is not specified, return all the paths.

        """

        routing_table = list(source_as.speakers.values())[0].routing_table

        routes = routing_table.get_route(ip)

        path_list = []
        count = 0
        for path in routes:
            as_path = [self.as_dict[asn] for asn in path]
            path_list.append(RoutingPath(as_path))
            count += 1
            if (max_num is not None) and (count >= max_num):
                break
        return path_list

    def add_noise_in_path(self, source_as, routing_path, noise_rate):
        """Add noise to an AS path specified by `routing_path`.
        The starting AS is specified by `source_as`.
        This function only changes the noise rate of the link between `source_as` and the first AS
        along the path, and other links will remain unchanged.

        Parameters
        ----------
        source_as : AS
            Source Autonomous System.
        routing_path : RoutingPath()
            An AS path.
        noise_rate : float
            The noise rate we want to set.

        """
        assert len(routing_path.as_list) > 0
        next_as = routing_path.as_list[0]
        first_speaker = self.get_speaker_to_as(source_as, next_as)
        next_speaker = first_speaker.find_next_speaker_via_asn(next_as.asn)
        qconn = self.first_speaker.speaker_to_connection[next_speaker]
        qconn.set_depolar_rate(noise_rate)

    def sort_path_list_by_benchmarking(self, source_as, ip, sequence, max_num=None):
        path_list = self.get_paths(source_as, ip, max_num)
        new_path_list = [path_list[i] for i in sequence]
        path_list = [path_list[i] for i in range(len(path_list)) if i not in sequence]
        new_path_list = new_path_list + path_list
        asn_list = []
        for path in new_path_list:
            asn_list.append([i.asn for i in path.as_list])
        for speaker in list(source_as.speakers.values()):
            # print(speaker)
            # print(speaker.routing_table)
            speaker.routing_table.change_route(ip, asn_list)

    def connect(self, a, b):
        '''
        Connect speaker `a` and `b` using both a classical connection and an entangling connection.
        This function is symmetric w.r.t `a` and `b`, i.e., `connect(a, b)` is equivalent to `connect(b, a)`.
        '''
        speaker1 = self.speaker_dict[a]
        speaker2 = self.speaker_dict[b]
        print(f"Connect {speaker1} and {speaker2}")
        print(f"ASN: {speaker1.asn} and {speaker2.asn}")
        # Let them know that they are neighbors
        speaker1.add_neighbor(speaker2)
        speaker2.add_neighbor(speaker1)

        # If the two speakers are not in the same AS, then we connect them via external quantum connections
        if speaker1.asn != speaker2.asn:
            # connection_len = 10
            self.avg_link_length
            qconn = EntanglingConnectionOnDemand(self.avg_link_length, self.channel_noise_rate)

            speaker1.qconn_num += 1
            speaker2.qconn_num += 1
            speaker1.add_ports([f"qconn{speaker1.qconn_num}"])
            speaker2.add_ports([f"qconn{speaker2.qconn_num}"])

            # Connect ports of two speakers using connections
            speaker1.ports[f"qconn{speaker1.qconn_num}"].connect(qconn.ports["A"])
            speaker2.ports[f"qconn{speaker2.qconn_num}"].connect(qconn.ports["B"])

            # Record which AS goes to which port
            speaker1.speaker_to_connection[speaker2] = qconn
            speaker2.speaker_to_connection[speaker1] = qconn
        else:
            # If the two speakers are in the same AS, then we connect them via internal quantum connections

            diameter = 50
            phantum_qconn = EntanglingConnectionOnDemand(diameter, self.channel_noise_rate)
            # Record which speaker goes via which connection
            speaker1.speaker_to_internal_qconn[speaker2] = phantum_qconn
            speaker2.speaker_to_internal_qconn[speaker1] = phantum_qconn
            # Add ports for this connection
            speaker1.internal_qport_num += 1
            speaker2.internal_qport_num += 1
            speaker1.add_ports([f"internal_qport{speaker1.internal_qport_num}"])
            speaker2.add_ports([f"internal_qport{speaker2.internal_qport_num}"])
            speaker1.ports[f"internal_qport{speaker1.internal_qport_num}"].connect(phantum_qconn.ports["A"])
            speaker2.ports[f"internal_qport{speaker2.internal_qport_num}"].connect(phantum_qconn.ports["B"])

    def simulate_traffic(
        self,
        distribution_name,
        arrival_rate,
        request_num,
        with_benchmark=False,
        random_pairs=[],
        enable_load_balancing=False,
    ):
        '''Generate requests to simulate traffic in the network and return network measurement results.'''

        self.compute_metrics_start()
        request_generator = RequestGenerator(self.as_dict, self.ip_list, distribution_name, arrival_rate, request_num,
                                             with_benchmark, random_pairs, enable_load_balancing)
        request_generator.start()
        ns.sim_run()
        metrics = self.compute_metrics_end()
        random_pairs = request_generator.get_random_pairs()
        metrics.append(random_pairs)
        print("Number of requests:", request_num)

        # For debugging only, in case the following assertion fails
        if self.num_successful_links() + self.num_failed_links() != request_num:
            x = [i for i in range(request_num)]
            for as_node in self.as_dict.values():
                for request_id in as_node.successful_links.keys():
                    x.remove(request_id)

            for as_node in self.as_dict.values():
                for request_id in as_node.failed_links.keys():
                    x.remove(request_id)
            print("Missing requests:", x)
        assert self.num_successful_links() + self.num_failed_links() == request_num

        for as_node in self.as_dict.values():
            for speaker in as_node.speakers.values():
                if speaker.request_id_list != []:
                    print("speaker.request_id_list:", speaker.request_id_list)
                # FIXME: This assertion may fail. This is a bug.
                assert speaker.request_id_list == []

        return metrics

    def compute_metrics_start(self):
        self.clock = ns.sim_time(ns.SECOND)

    def compute_metrics_end(self):
        """Returns network measurement metrics:
        Throughput: number of successful links / elapsed time
        Goodput: sum of fidelity of successful links / elapsed time
        Average latency: sum of latency of successful links / number of successful links
        """
        elapsed_time = ns.sim_time(ns.SECOND) - self.clock
        num_links = 0
        sum_fidelity = 0
        sum_latency = 0
        for as_node in self.as_dict.values():
            num_links += len(as_node.successful_links)
            for (entanglement, fidelity) in as_node.successful_links.values():
                sum_latency += entanglement.latency
                sum_fidelity += fidelity

        return [num_links / elapsed_time, sum_fidelity / elapsed_time, sum_latency / num_links]

    def print_routing_table(self):
        # Print routing tables for all ASs
        print("Routing tables:")
        for as_node in self.as_dict.values():
            as_node.print_routing_table()

    def num_successful_links(self):
        num_success_link = 0
        for as_node in self.as_dict.values():
            num_success_link += len(as_node.successful_links.values())
        return num_success_link

    def num_failed_links(self):
        count = 0
        for as_node in self.as_dict.values():
            for request_id, failed_msg in as_node.failed_links.items():
                count += 1
        return count

    def print_successful_links(self):
        num_success_link = 0
        for as_node in self.as_dict.values():
            num_success_link += len(as_node.successful_links.values())
        print(f"\nNumber of successful links: {num_success_link}")

        # Print fidelity
        print("Fidelities of each link:")
        count = 0
        for as_node in self.as_dict.values():
            for request_id, (link, fidelity) in as_node.successful_links.items():
                count += 1
                print(f"({count}) {link}, fidelity: {fidelity}, request ID: {request_id}")

    def print_failed_links(self):
        print("")
        count = 0
        for as_node in self.as_dict.values():
            for request_id, failed_msg in as_node.failed_links.items():
                count += 1
                print(f"({count}) request ID: {request_id}, failed reason: {failed_msg}")
        print(f"Number of failed links: {count}")

    def start(self):
        super().start()

        # Simulate BGP, which propagate routing information in the network
        ns.sim_run()

    def reset(self):
        """Reset the traffic of the whole network, but keep the routing table unchanged."""
        for as_node in self.as_dict.values():
            as_node.reset()

        for protocol in self.protocols.values():
            for subprotocol in protocol.subprotocols.values():
                subprotocol.reset()

        RoutingRequest.request_id = 0


class RoutingTable:
    '''The routing table stored in each AS.'''

    def __init__(self):
        # dictionary from IP to routing path
        self.table = {}

    def has_route(self, ip, path):
        return ip in self.table and path in self.table[ip]

    def add_route(self, ip, path):
        if ip in self.table.keys():
            self.table[ip].append(path)
            self.table[ip].sort(key=len)
        else:
            self.table[ip] = [path]

    def get_route(self, ip):
        return self.table.get(ip)

    def change_route(self, ip, path_list):
        original = self.table[ip]
        for i in path_list:
            if i in original:
                original.remove(i)
        path_list = path_list + original
        self.table[ip] = path_list

    def __str__(self):
        output_str = ""
        for (ip, path) in self.table.items():
            output_str += "IP: {}, Path: {}\n".format(ip, path)
        return output_str


class BGPSpeaker(Node):
    '''A router that runs the BGP protocol in an Autonomous System. It announces/receives routes to/from its neighbors.'''

    def __init__(self, speaker_id, parent_as, capacity):
        gate_noise_rate = parent_as.parent_network.gate_noise_rate
        qmemory = create_qprocessor(capacity, gate_noise_rate)  # Quantum memory that stores qubits
        super().__init__(name=str(speaker_id), qmemory=qmemory)
        self.speaker_id = speaker_id
        self.speaker_to_connection = {}  # Mapping from speaker to entangling connection
        self.speaker_to_internal_qconn = {}
        self.qconn_num = 0  # Number of external quantum connection to other ASs
        self.internal_qport_num = 0  # Number of internal quantum connection to the same AS
        self.parent_as = parent_as  # The AS that owns this speaker
        self.parent_network = parent_as.parent_network  # The network that owns this speaker
        self.asn = parent_as.asn  # The AS number that the speaker belongs to
        self.i_neighbors = []  # Internal neighbors, i.e., speakers from the same AS
        self.e_neighbors = []  # External neighbors, i.e., speakers from other ASs
        self.current_requests = {}  # Routing requests that are being handled by the speaker, indexed by request id
        # Records the next hop speaker used for the requests, useful when forwarding measurement results
        self.request_to_next_hop = {}
        self.routing_table = RoutingTable()  # Routing table stored in the speaker
        # Stores the measurement results if the corresponding request hasn't arrived yet
        self.measurement_buffer = {}  # Mapping from request id to a list of measurement results
        self.request_id_list = []  # Stores all the request IDs that are sent from this speaker

        # Initialize ports for each speaker:
        # We assume that all speakers can freely communicate with each other via classical port "cconn"
        # Speakers will start their correction protocols via port "correction_trigger"
        self.add_ports(["cconn", "correction_trigger"])

    def reset(self):
        self.qmemory.reset()
        self.current_requests.clear()
        self.request_to_next_hop.clear()
        self.measurement_buffer.clear()
        self.request_id_list.clear()

    def __str__(self):
        return "Speaker{}".format(self.speaker_id)

    def qmem_available(self):
        return len(self.qmemory.unused_positions) >= 1

    def find_next_speaker_via_asn(self, asn):
        '''
        Given a remote ASN that the speaker wants to access, finds an appropriate next-hop speaker.
        The next-hop speaker is either in the same AS, i.e., we need to launch an iBGP, or it is in other AS.
        '''
        found = False
        # Prefer external neighbors
        for next_speaker in self.e_neighbors:
            if next_speaker.asn == asn:
                found = True
                return next_speaker
        # If cannot find in all the external neighbors, try internal ones
        for next_speaker in self.i_neighbors:
            for next_next_speaker in next_speaker.e_neighbors:
                if next_next_speaker.asn == asn:
                    found = True
                    return next_speaker

        if not found:
            return None

    def get_next_hop_speaker(self, msg):
        """Find a route in the routing table."""
        route = self.routing_table.get_route(msg.dest_ip)

        if route is not None:
            shortest_route = route[0]  # Greedy: always choose the shortest one. Note that `route` is sorted.
            if shortest_route != []:
                next_asn = shortest_route[0]
                next_speaker = self.find_next_speaker_via_asn(next_asn)
                return next_speaker
        return None

    def add_neighbor(self, neighbor):
        if neighbor.asn == self.asn:
            self.i_neighbors.append(neighbor)
        else:
            self.e_neighbors.append(neighbor)


class AS(Node):
    '''Autonomous System, which contains a set of nodes in the network graph.'''

    def __init__(self, parent_network, asn):
        self.asn = asn
        self.parent_network = parent_network
        self.speakers = {}
        self.successful_links = {}  # Mapping from request id to Entanglement
        self.failed_links = {}  # Mapping from request id to string
        self.add_ports(["cconn"])  # Classical communication port used to receive information about entanglement links

    def reset(self):
        self.successful_links.clear()
        self.failed_links.clear()
        for speaker in self.speakers.values():
            speaker.reset()

    def add_speaker(self, speaker_id, capacity):
        self.speakers[speaker_id] = BGPSpeaker(speaker_id, self, capacity)

    def neighbor_speaker_num(self):
        """Return the number of external speakers that connect to this AS."""
        neighbors_num = 0
        for speaker in self.speakers.values():
            neighbors_num += len(speaker.e_neighbors)
        return neighbors_num

    def print_routing_table(self):
        print("AS{}:".format(self.asn))
        for speaker in self.speakers.values():
            print("Speaker{}:\n{}".format(speaker.speaker_id, speaker.routing_table))

    def __repr__(self):
        return "AS{}".format(self.asn)
